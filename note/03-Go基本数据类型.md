# 03-Go语言基本数据类型与运算符

| 数据类型                                                |            |
| ------------------------------------------------------- | ---------- |
| bool                                                    | 布尔类型   |
| string                                                  | 字符串     |
| int   int8   int16    int32    int64                    | 整型       |
| uint  uint8  uint16  uint32   uint64   uintptr          | 无符号整型 |
| byte //alias for uint8                                  | 字节型     |
| rune //alias for int32, represents a Unicode code point | 字符型     |
| float32  float64                                        | 浮点型     |
| complex64  complex128                                   | 复数型     |

**类型后面的数字标识数据类型的bite位数**

需要注意的是：

> int uint 的长度是根据平台相关的 unintptr同指针的长度 在32位平台下为4字节，64位平台下为8字节



## 类型转化

与其他语言的差异

1. **Go语言不允许隐式类型转化**
2. **别名和原有类型也不能进行隐式类型转换**



```go
package type_test

import "testing"

type MyInt int64

/**
测试隐式类型转换的约束
结论：不支持隐式类型转换
	别名也被允许隐式类型转换
如果想要转换则需要显示的类型强转，但是需要注意类型强转可能会发生截短，导致数据精度损失和值溢出的问题
*/
func TestImplicit(t *testing.T) {
	var a int32 = 1
	var b int64
	b = int64(a)
	var c MyInt
	c = MyInt(b)
	t.Log(a, b,c)
}
```

> **如果想要转换则需要显示的类型强转，但是需要注意类型强转可能会发生截短，导致数据精度损失和值溢出的问题**
>
> 比如：浮点型强转成整数会发生损失精度
>
> ​		  值超过转换目标的类型的值范围时会导致值溢出的问题



## 类型的预定义值

1. math.MaxInt64  //9223372036854775807
2. math.MaxFloat64  //1.7976931348623157e+308 
3. math.MaxUnit32 //4294967295

## 指针类型

与其主要编程语言的差异

1. **不支持指针的运算**
2. **string时值类型，其默认的初始化值为空字符串，而不是nil**

```go
/**
测试指针的使用及限制
go语言中支持指针 但是不支持指针的运算
*/
func TestPoint(t *testing.T) {
	a := 1
	aPtr := &a
	c := &aPtr
    
	//不支持指针的运算
	//aPtr+= 1    
    //. \type_test.go:29:6: invalid operation: aPtr += 1 (mismatched types *int and int)
    
	t.Log(a, aPtr, c)        //1  0xc00004e290 0xc00007c028
	t.Logf("%T %T %T", a, aPtr,c) //int  *int **int
}
```

**判断一个字符串是否为“空”**

```go
/**
string在go中是数值类型 在初始化时会初始化为""字符串 而不是nil
 */
func TestString(t *testing.T) {
	var s string
	t.Log("*" +s + "*") //**
	t.Log(len(s)) //0

	//判断一个字符串是否为空在go中如下判断
	if s==""{
		//...
	}
	if len(s) == 0{
		//...
	}
}
```



## 运算符

### 算术运算符

| 运算符  | 描述   | 实例 A = 10 B = 20  |
| ------- | ------ | ------------------- |
| +       | 相加   | A + B  输出结果 30  |
| -       | 相减   | A - B  输出结果 -10 |
| *       | 相乘   | A * B  输出结果 200 |
| /       | 相除   | B / A  输出结果 2   |
| %       | 求余数 | B % A 输出结果 0    |
| 后置++  | 自增   | A++   输出结果 11   |
| 后置- - | 自减   | A–     输出结果 9   |

> 注意:
>
> **Go语言没有前置++,  - -**



### 比较运算符

| 运算符 | 描述               | 实例         |
| ------ | ------------------ | ------------ |
| ==     | 同其他主流编程语言 | A == B False |
| !=     | …                  | …            |
| >      | …                  | …            |
| <      | …                  | …            |
| >=     | …                  | …            |
| <=     | …                  | …            |

> 注意：
>
> **比较运算符和其他编程语言一样，只是在某些类型上的比较方式有自己特殊的规则与方式，不直接使用比较运算符。**



### 用 == 比较数组

- 相同维数且含有相同个数的元素的数组才可以进行比较
- 每个元素都相同的才相等

```go
package operator_test

import "testing"

/**
数组的比较
- 相同维数且含有相同个数的元素的数组才可以进行比较
- 每个元素都相同的才相等，反之不等
 */
func TestCompareArray(t *testing.T) {
	a:=[...]int{1,2,3,4}
	b:=[...]int{1,3,4,5}
	//c:=[...]int{1,2,3,4,5}
	d:=[...]int{1,2,3,4}
	t.Log(a==b) //false
    t.Log(a==d) //true
    
	//相同维数且含有相同个数的元素的数组才可以进行比较
    //t.Log(a==c) 
    //.\operator_test.go:11:9: invalid operation: a == c (mismatched types [4]int and [5]int)
}
```



## 逻辑运算符

| 运算符 | 描述          | 实例            |
| ------ | ------------- | --------------- |
| &&     | 逻辑AND运算符 | (A && B) False  |
| \|\|   | 逻辑OR运算符  | (A \|\| B) True |
| ！     | 逻辑NOT运算符 | !(A && B) True  |

 

## 位运算符

| 运算符 | 描述                                 | 实例      |
| ------ | ------------------------------------ | --------- |
| &      | 按位与“&”两数的二进制位相与          |           |
| \|     | 按位或“\|”两数的二进制位相或         |           |
| ^      | 按位异或运算符“^””两数的二进制位异或 | x ^ y     |
| <<     | 左移运算符“<<” 乘以2的n次方          |           |
| \>>    | 右移运算符“>>”除以2的n次方           |           |
| ^      | **按位取反**                         | **^x**    |
| &^     | **按位置零**                         | 1 &^ 0 —1 |

### 特别的按位置零 &^

```go
1 &^ 0 -- 1
1 &^ 1 -- 0
0 &^ 1 -- 0
0 &^ 0 -- 0
```

> **左边操作数二进制位对应的右边操作数的二进制位中对应为1的位全部清零**
>
> **如果右边操作数是0则，左边操作数原来是什么结果还是什么**

```go
/**
分别用二进制的三个位标识，三种状态
*/
const (
	Readable   = 1 << iota //可读
	Writable               //可写
	Executable             //可执行
)

/*
&^清零操作符的使用
*/
func TestBitClear(t *testing.T) {
	a := 7 //0111

	//清除读和可执行功能的功能
	a = a &^ Readable
	a &^= Executable
	t.Log(a&Readable == Readable, a&Writable == Writable, a&Executable == Executable) //false true false
}
```

