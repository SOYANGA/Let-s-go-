# 15-协程机制

***go语言最具特点的协程机制***

## Thread VS Groutine（线程 协程）

1. 创建时默认的stack的大小
   - JDK5以后Java Thread stack默认为1M
   - Groutine的stack初始化大小为2K
2. 和KSE(Kernel Space Entity)的对应关系
   - Java Thread 1:1(Thread - 系统线程)
   - Groutine 是 M:N
   
   <img src="D:\内功修炼心法\go\picture\KSE.png" alt="1569773316662" style="zoom:67%;" />

## Go的协程基本调度机制

<img src="D:\内功修炼心法\go\picture\Go中协程基本调度机制.png" alt="1569773487394" style="zoom:67%;" />

- **M:系统线程**
- **P:Go语言的协程处理器**
- **G:Go中的协程**

> 每个系统线程对应一个协程处理器且协程处理其上挂载的是准备要处理的协程，Go是正在运行的协程。
>



> 假如一个协程把协程处理器占用的时间特别长，在go运行起来的时候会有一个守护线程会去记每个协程处理器完成协程的数量，当一段时间发现某个协程完成的数量不会发生变化时，他就会往协程的任务栈里添加特殊一个标记。当协程运行的时候会遇到这个非内联函数的时候就会读到这个标记，就会把自己中断插入到等候协程的队尾让其他协程运行。
>



> **提高整个并发能力的机制**
>
> 当某个协程被系统中断了，比如IO需要等待的时候，为了提高整体的并发。协程处理器会把自己移动到另一个可使用线程当中，继续执行他所挂的队列里面的其他协程。当这个被中断的协程被唤醒，完成之后会把自己加入到其中某一个协程处理器所挂载的协程等待队列里，或者是全局等待队列当中。
>

> 注意：
>
> 当一个协程被中断时，他在寄存器的运行状态，也会保存在这个协程对象里面。当协程再次获取运行机会时，这些又会重新写入寄存器然后继续运行，大致我们看到了go的协程机制和系统线程多对多的关系，以及**高效利用系统线程来尽量多的运行并发的协程任务**
>



## 简单实践

```go
package groutine__test

import (
	"fmt"
	"testing"
	"time"
)

func TestGroutine(t *testing.T) {
	for i := 0; i < 10; i++ {
		go func(i int) {
			fmt.Println(i)
		}(i)
	}
	time.Sleep(time.Millisecond * 50)
}
```



## 共享内存并发机制

### Lock

```java
Lock lock  = ...;
lock.lock();
try{
	//process(thread-safe)
}catch(Exception ex) {

}finally{
	lock.unlock();
}
```



Go中的共享内存并发机制所需要的包为``package sync 其中的 Mutex（互斥锁） RWLock`（读写锁）



### 案例：多协程自增

```go
package share_mem

import (
	"sync"
	"testing"
	"time"
)

//共享内存counter多协程自增测试（不加锁） //4966不符合预期 非线程安全
func TestCounter1(t *testing.T) {
	counter := 0
	for i := 0; i < 5000; i++ {
		go func() {
			counter++
		}()
	}
	time.Sleep(1 * time.Second)
	t.Logf("counter = %d", counter)
}

//共享内存counter多协程自增测试（加锁） //5000符合预期 线程安全
func TestCounter2(t *testing.T) {
	//获取锁
	var mut sync.Mutex
	//共享资源
	counter := 0
	for i := 0; i < 5000; i++ {
		//协程并发执行
		go func() {
			//加锁
			mut.Lock()
			counter++
			//每个协程在执行完后进行解锁
			defer func() {
				mut.Unlock()
			}()
		}()
	}
	time.Sleep(1 * time.Second)
	t.Logf("counter = %d", counter)
}
```



### waitGroup(线程之间的等待)

```
var wg sync.WaitGroup

for i := 0; i < 5000; i++ {
	wg.Add(1)
	go func() {
		defer func() {
			wg.Done()
		}()
		...
	}()
} 
wg.Wait()
```

**解决主线程优雅的等待其他线程的问题**

```go
//共享内存counter多协程自增测试 + WaitGroup测试（主线程需要等待协程全部做完后再执行的方法）
func TestCounter3(t *testing.T) {
	//获取锁
	var mut sync.Mutex
	var wg sync.WaitGroup
	//共享资源
	counter := 0
	for i := 0; i < 5000; i++ {
		//协程并发执行每次启动一次执行，我们就需要添加一个我们需要等待的协程
		wg.Add(1)
		go func() {
			//加锁
			mut.Lock()
			counter++
			//每个协程在执行完后进行解锁并减少一次我们需要等待的协程
			defer func() {
				wg.Done()
				mut.Unlock()
			}()
		}()
	}
	wg.Wait()
	t.Logf("counter = %d", counter)
}
```



### RWLock

读写锁，将读跟写分开。共享资源被读锁锁住时，读请求可以继续处理，而被写锁锁住时读写请求都不得阻塞直到写锁释放共享资源

**适合读多写少的场景。**，大大提高运行效率。